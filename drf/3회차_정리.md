## DRF STUDY 3회차

### 비모강사님의 질문 (vue, drf를 키워드로!)

* 토큰을 발급 받는다. 토큰을 프론트엔드에게 전달한다. 
* 프론트엔드는 그 토큰을 어떻게 관리하나? 
* 프론트엔드는 그 토큰을 어떻게 서버(백엔드)에게 전달하나? 
* 백엔드는 토큰을 받아서 어떻게 사용자를 판단하나?(-> 어떻게 권한처리를 하나?)

이에 대한 해답을 얻기 위해, vue에서 로그인의 상태관리를 어떻게 하는지 알아보았다.

* vue에서는 클라이언트가 로그인 정보를 요청하면

* 익명상태(State)를 인증된 유저(Authenticated)로 바꾸는 행동(Action)을 취해야 하고

* 행동(Action)이 변이(Mutation)을 발생시킨다.

* state → actions → mutations → state 순서인 것이다.
* state에서는 유저 정보와 로그인 확인 여부, 그리고 로그인 실패시 에러와 관련된 data 옵션을 지정한다.
* mutations에는 state값에 변화를 줄 수 있는 함수들, 로그인 성공, 로그인 실패, 로그아웃을 지정한다.
* 발생하는 actions는 총 4개다. 로그인, 로그아웃, 회원가입, 유저정보를 가져오는 함수이다.

프론트엔드는 토큰을 로컬 스토리지에 저장해 관리한다.

토큰을 헤더 정보에 포함시켜서 유저 정보를 요청한다.

[참고링크](https://equus3144.medium.com/drf-django-rest-framework-and-vue-js-8fb39d5f5192)

### 유저 인증 및 권한 부여

```python
# permissions.py

from rest_framework import permissions


class IsOwnerOrReadOnly(permissions.BasePermission):
    def has_object_permission(self, request, view, obj):
        # 읽기 권한 요청이 들어오면 허용
        if request.method in permissions.SAFE_METHODS:
            return True

        # 요청자(request.user)가 객체(Blog)의 user와 동일한지 확인
        return obj.user == request.user
    
# views.py

class ArticleViewSet(viewsets.ModelViewSet):
    permission_classes = [IsOwnerOrReadOnly]
    queryset = Article.objects.all()
    serializer_class = ArticleSerializer

    def perform_create(self, serializer):
        serializer.save(user=self.request.user)
```

내가 원하는 권한을 커스텀해서 적용시킬 수 있었다.

### 1:N 댓글

```python
#models.py

class Comment(models.Model):
    id = models.AutoField(primary_key=True, null=False, blank=False)
    article = models.ForeignKey(
        Article, null=False, blank=False, on_delete=models.CASCADE
    )
    user = models.ForeignKey(
        settings.AUTH_USER_MODEL, null=False, blank=False, on_delete=models.CASCADE
    )
    created_at = models.DateField(auto_now_add=True, null=False, blank=False)
    comment = models.TextField()

    def __str__(self):
        return self.comment

# serializers.py

class CommentSerializer(serializers.ModelSerializer):
    user = serializers.ReadOnlyField(source="user.nickname")

    class Meta:
        model = Comment
        fields = [
            "id",
            "article",
            "user",
            "created_at",
            "comment",
        ]

    
# views.py

class CommentViewSet(viewsets.ModelViewSet):

    permission_classes = [IsOwnerOrReadOnly]
    queryset = Comment.objects.all()
    serializer_class = CommentSerializer

    def perform_create(self, serializer):
        serializer.save(user=self.request.user)

# urls.py

router.register("comment", views.CommentViewSet, basename="comment")
urlpatterns = [path("", include(router.urls))]
```

1:N관계를 모델에서 정의 한 후, 위와 같이 시리얼라이져, 뷰, url을 설정한다.

### 
